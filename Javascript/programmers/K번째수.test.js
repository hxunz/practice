// 1. 문제에 대한 이해
// 우리가 풀어야 할 문제는 무엇인가?
// 배열array에서 i번째 부터 j번째까지 자르고 이 새로운 배열을 정렬시킨다음에 k번째 숫자가 무엇인지 찾아라

// 주어진 자료는 무엇인가?
// array와 i, j, k를 담은 2차원 배열인 commands

// 조건은 무엇인가?
// commands의 원소의 길이는 3이다.
// 근데 문제에서 인덱스가 0부터 시작하는거 고려 안해줘서 i => i-1, j-1, k-1 로 바꿔줘야댐

// 2. 계획
// 이 문제를 푸는데 있어서 유용하게 쓸 수 있는 지식은 무엇인가?
// slice sort

// commands의 길이가 무조건 3이니까 배열을 나눈다. [[2, 5, 3], [4, 4, 1], [1, 7, 3]] -> [2, 5, 3], [4, 4, 1], [1, 7, 3] 이렇게
// 근데 저렇게 둘 수 없으니까 const first = [2, 5, 3] 이런식으로 해줌
// 빈 배열 하나 만들어두고 newArr
// array.slice[first[0]-1, first[1]] 해줘서 빈 배열에 넣어준다.
// first[1]해준 이유는 slice하니까

// 빈배열에 값들이 쌓였으니까 이걸 sort()해서 정렬해준다.
// 결과를 담을 빈 배열 만든다,
// 정렬된 배열에서 newArr[first[2]+1] 한 값을 결과배열에 넣어준다.

// 3. 실행
// 풀이 계획을 실행하고, 각 단계가 올바른지 점검하라.

// 4. 반성
// 문제를 다른 방식으로 해결할 수 있는가?
// 반복되는게 있어서 먼가,,, map 쓸 수 있을듯,,,?

// 결과나 방법을 어떤 다른 문제에 활용할 수 있는가?
// 어떻게 하면 더 효율적으로 문제를 해결할 수 있는가?
// 어떻게 하면 더 효과적으로 문제를 해결할 수 있는가?
// 중복되는것 반복되는 로직을 줄여보자



const solution = (array, commands) => {
    const result = commands.map((num) => {
        const arr = array.slice(num[0] - 1, num[1]).sort((a, b) => a - b);
        return arr[num[2] - 1];
    })
 
    return result;
};

test('i번째 부터 j번째 까지 자른 수를 넣은 배열', () => {
    expect(solution([1, 5, 2, 6, 3, 7, 4], [[2, 5, 3], [4, 4, 1], [1, 7, 3]])).toBe([5, 6, 3]);
});

test('commands배열 안에 한개의 배열만 있는 경우', () => {
    expect(solution([1, 5, 2, 6, 3, 7, 4], [[2, 5, 3]])).toBe([5]);
});
