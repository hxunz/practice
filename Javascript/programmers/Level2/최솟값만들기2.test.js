/**
* ## 이해
*
* 미지의 것: 최종적으로 누적된 최솟값을 return
* 자료
*   - 길이가 같은 배열 A, B 두개가 있습니다.
    - 배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다.
    - 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다.
    - 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다.
    - 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.
* 조건
*   -
*
* ## 계획
*   - A,B 순서대로 돌면서 위치가 같은 숫자 끼리 곱한다.
    - 이 값들을 누적해서 더한다.
    - 배열을 다 돌면 누적값을 리턴한다.
*
* ## 실행
*
* ## 반성
*
*/

const solution = (A, B) => {
  const a = A.sort((a, b) => a - b);
  const b = B.sort((a, b) => b - a);

  return a.reduce((acc, cur, index) => {
    return acc + cur * b[index];
  }, 0)
};

test('solution', () => {
  expect(solution([1, 4, 2], [5, 4, 4])).toBe(29)
  expect(solution([1, 2], [3, 4])).toBe(10)
})