/**
* ## 이해
*
* 미지의 것: 모든 문제들을 풀 수 있는 알고력과 코딩력을 얻는 최단시간을 return
* 자료
*   - 알고리즘에 대한 지식은 알고력, 코드를 구현하는 능력은 코딩력이라고 표현
    - 알고력과 코딩력은 0 이상의 정수로 표현
    - 알고력과 코딩력을 높이기 위한 다음과 같은 방법이 있다.
      - 알고력 1을 높이기 위해서 1의 시간이 필요합니다.
      - 코딩력 1을 높이기 위해서 1의 시간이 필요합니다.
      - 현재 풀 수 있는 문제 중 하나를 풀어 알고력과 코딩력을 높입니다.
      - 각 문제마다 문제를 풀면 올라가는 알고력과 코딩력이 정해져 있습니다.
    - 문제를 하나 푸는 데는 문제가 요구하는 시간이 필요하며 같은 문제를 여러 번 푸는 것이 가능합니다.
    - problems의 원소는 [alp_req, cop_req, alp_rwd, cop_rwd, cost]의 형태
* 조건
*   -
*
* ## 계획
*   - 현재의 알고력 혹은 코딩력으로 풀 수 있는 문제를 찾는다.
    - 해당 문제를 풀면서 알고력 혹은 코딩력을 늘린다.
      - 이 때, 소요 시간을 누적하고 있는다.
    - 해당 문제를 풀기 위한 알고력과 코딩력이 도달한 경우
      - 다음 문제를 찾는다. 문제를 푸는 순서는 알고력과 코딩력이 낮은 순서대로 푼다.
      - 위의 과정을 반복한다.
    - 모든 문제를 다 풀었을 경우 총 소요 시간을 리턴한다.
*
* ## 실행
*
* ## 반성
*
*/
// problems = [알고력, 코딩력, 증가하는알고력, 증가하는코딩력, 문제풀이소요시간]
const solution = (alp, cop, problems) => {
  const sortedProblems = problems.sort((a, b) => (a[0] + a[1]) - (b[0] + b[1]));
  let totalTimes = 0;
  sortedProblems.forEach(([alp_req, cop_req, alp_rwd, cop_rwd, cost]) => {
    if (alp_req <= alp || cop_req <= cop) {
      
    }
  })
};

test('solution', () => {
  expect(solution(10, 10, [[10, 15, 2, 1, 2], [20, 20, 3, 3, 4]])).toBe(15);
})